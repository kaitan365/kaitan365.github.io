{
  "hash": "a5bbff2896e2a732e720627d2bbea8b2",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Write efficient Python code\"\nauthor: \"Kai Tan\"\ndate: \"2024-05-01\"\ncategories: [Blog, coding]\nformat:\n  html:\n    code-fold: false\njupyter: python3\n---\n\n\n\n\n\n## Use broadcasting to avoid creating a diagonal matrix\n    - Use A * v instead of A @ np.diag(v)\n    - Use v[:, np.newaxis] * A instead of np.diag(v) @ A\n\n::: {#9a98f11f .cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nimport timeit\nA = np.random.randn(1000, 1000)\nv = np.random.randn(1000)\nassert np.all( A @ np.diag(v) == A * v )\nassert np.all( np.diag(v) @ A == v[:, np.newaxis] * A )\nprint('time for method 1:', timeit.timeit(lambda: A @ np.diag(v), number=10))\nprint('time for method 2:', timeit.timeit(lambda: A * v, number=10))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntime for method 1: 0.20621375006157905\ntime for method 2: 0.017127083032391965\n```\n:::\n:::\n\n\n## Avoid large matrix multiplication\n    - Use np.sum(A * B.T) instead of np.trace(A @ B)\n\n::: {#8e77dddf .cell execution_count=2}\n``` {.python .cell-code}\nimport numpy as np\nimport timeit\nA = np.random.randn(1000, 1000)\nB = np.random.randn(1000, 1000)\nassert np.isclose(np.trace(A @ B), np.sum(A * B.T))\nprint('time for method 1:', timeit.timeit(lambda: np.trace(A @ B), number=10))\nprint('time for method 2:', timeit.timeit(lambda: np.sum(A * B.T), number=10))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntime for method 1: 0.19951483292970806\ntime for method 2: 0.028284332947805524\n```\n:::\n:::\n\n\n## Prioritize the order of matrix multiplication\n    - Use A @ (B @ v) instead of A @ B @ v if v is a vector. \n\n::: {#6f57a44a .cell execution_count=3}\n``` {.python .cell-code}\nimport numpy as np\nimport timeit\nA = np.random.randn(1000, 1000)\nB = np.random.randn(1000, 1000)\nv = np.random.randn(1000)\nassert np.allclose(A @ B @ v, A @ (B @ v))\nprint('time for method 1:', timeit.timeit(lambda: A @ B @ v, number=10))\nprint('time for method 2:', timeit.timeit(lambda: A @ (B @ v), number=10))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntime for method 1: 0.21710574999451637\ntime for method 2: 0.0016295830719172955\n```\n:::\n:::\n\n\n",
    "supporting": [
      "blog1_files"
    ],
    "filters": [],
    "includes": {}
  }
}